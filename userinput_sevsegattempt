`timescale 1ns / 1ps


module guess_with_dice(new_game, reset, roll, hold, clk, lfsr_result, an, a, b, c, d, e, f, g, P1, P2);

input reset, clk; //50Mhz
input new_game; //starting new game
input roll; // button to roll a dice
input hold; //hold player's turn score and store in total score, switch turn to next player.
input [5:0] lfsr_result;  //rand num generated by lfsr.

output a, b, c, d, e, f, g; //cathodes
output [6:0] an; //anodes

output P1, P2;//shows which player is playing.

reg [7:0] PS1;//store total score of player 1
reg [7:0] PS2;//store total score of player 2
reg [7:0] SUM;//store score earned from dice in current turn

reg [3:0] p1d2 = 0;// player 1's second digit
reg [3:0] p1d1 = 0;// player 1's first digit
reg [3:0] p2d2 = 0;// player 2's second digit
reg [3:0] p2d1 = 0;// player 2's first digit
reg [3:0] sumd2 = 0;// turn total score's second digit
reg [3:0] sumd1 = 0;// turn total score's first digit
reg [3:0] diceroll;// dice number (1-6)

reg [27:0] counter;

reg P1 = 1, P2 = 0; //switches player who begins game

reg roll_push = 0;
reg new_push = 0;
reg hold_push = 0;

wire increase;

// reset should reset all variables (scores) to 0.
// roll a die, add it to sum, check against random number.
// if too low, roll again, can roll 1 time before switching players.
// if too high, reset player sum to 0.
// if exact, player wins.
always@(posedge clk or posedge reset)
  begin
    if(reset)
        counter <= 0;
    else if(counter == 100000000)
        counter <= 0;
    else
        counter <= counter + 1;
  end
  
assign increase = ((counter == 100000000)?1'b1:1'b0);
  
always@(posedge clk)
    begin
       if(reset)
         begin
          PS1 <= 0;
          PS2 <= 0;
          SUM <= 0;
          
          p1d2 <= 0;
          p1d1 <= 0;
          p2d2 <= 0;
          p2d1 <= 0;
          sumd2 <= 0;
          sumd1 <= 0;
          
          diceroll <= 0;
          
          P1 <= 1;
          P2 <= 0;
         end
         
        if(new_game == 1)
         begin
          PS1 <= 0;
          PS2 <= 0;
          SUM <= 0;
          
          p1d2 <= 0;
          p1d1 <= 0;
          p2d2 <= 0;
          p2d1 <= 0;
          sumd2 <= 0;
          sumd1 <= 0;
          
          diceroll <= 0;
          
          P1 <= ~P1;
          P2 <= ~P2;
         end
         
         //die goes up by 1 every .01 seconds while roll switch is high
         if(roll)
            begin
//                roll_push <= 1;
//                if(diceroll == 4'b0110)
//                 diceroll <= 4'b0001;
//                else
//                 diceroll <= diceroll + 4'b0001;
                diceroll <= 4'b0110;
                roll_push <= 1;
            end
          
         if(roll == 0 && roll_push == 1)
            begin
              
              if(P1 == 1)
               begin
                if(diceroll == 4'b0001)
                 begin
                  SUM <= 8'b00000000;
                  P1 <= 0;
                  P2 <= 1;
                 end
                 else
                  SUM <= SUM + diceroll;
               end
              
              else if(P2 == 1)
               begin
                if(diceroll == 4'b0001)
                 begin
                  SUM <= 8'b00000000;
                  P1 <= 1;
                  P2 <= 0;
                 end
                 else
                  SUM <= SUM + diceroll;
               end
               
              roll_push <= 0;
            end
            
         else if((PS1 > lfsr_result || PS1 == lfsr_result || PS2 > lfsr_result || PS2 == lfsr_result) && roll == 1)
            begin
             diceroll <= 4'b0000;
            end
            
          if(hold == 1 && hold_push==0)
              begin
               hold_push <= 1;
              end
          else if(hold == 0 && hold_push == 1)
              begin
                begin
                  if(P1 == 1 && P2 == 0)
                   begin
                    PS1 <= PS1 + SUM;
                    P1 <= 0;
                    P2 <= 1;
                    SUM <= 8'b00000000;
                    if(PS1 > lfsr_result || PS1 == lfsr_result)
                     begin
                      P1 <= 1;
                      P2 <= 0;
                     end
                    hold_push <= 0;
                   end
               else if(P1 == 0 && P2 == 1)
                begin
                  PS2 <= PS2 + SUM;
                  P1 <= 1;
                  P2 <= 0;
                  SUM <= 8'b00000000;
                    if(PS2 > lfsr_result || PS2 == lfsr_result)
                     begin
                     P1 <= 0;
                     P2 <= 1;
                     end
                end
               end
              end
    end
//score data (convert 8 bit to tens and ones place)
reg [3:0] i = 0;
reg [19:0] shift_register_sum = 0;
reg [19:0] shift_register_ps1 = 0;
reg [19:0] shift_register_ps2 = 0;

reg [3:0] temp_hundreds_sum;
reg [3:0] temp_tens_sum = 0;
reg [3:0] temp_ones_sum = 0;

reg [3:0] temp_hundreds_ps1;
reg [3:0] temp_tens_ps1 = 0;
reg [3:0] temp_ones_ps1 = 0;

reg [3:0] temp_hundreds_ps2;
reg [3:0] temp_tens_ps2 = 0;
reg [3:0] temp_ones_ps2 = 0;

reg [7:0] sum_hold = 0;
reg [7:0] PS1_hold = 0;
reg [7:0] PS2_hold = 0;

always@(posedge clk)
begin
    if(i == 0 & (sum_hold != SUM))
     begin
      shift_register_sum = 20'd0;
      sum_hold = SUM;
      
      shift_register_sum[7:0] = SUM;
      
      temp_hundreds_sum = shift_register_sum[19:16];
      temp_tens_sum = shift_register_sum[15:12];
      temp_ones_sum = shift_register_sum[11:8];
      
      i = i+1;
     end
    if(i < 9 & i > 0)
     begin
      if(temp_hundreds_sum >= 5) temp_hundreds_sum = temp_hundreds_sum + 3;
      if(temp_tens_sum >= 5) temp_tens_sum = temp_tens_sum + 3;
      if(temp_ones_sum >= 5) temp_ones_sum = temp_ones_sum + 3;
      
      shift_register_sum[19:8] = {temp_hundreds_sum, temp_tens_sum, temp_ones_sum};
      shift_register_sum = shift_register_sum << 1;
      
      temp_hundreds_sum = shift_register_sum[19:16];
      temp_tens_sum = shift_register_sum[15:12];
      temp_ones_sum = shift_register_sum[11:8];
      
      i = i + 1;
     end
    if(i == 9)
     begin
      i = 0;
      sumd1 = temp_tens_sum;
      sumd2 = temp_ones_sum;
     end
    
    if(i == 0 & (PS1_hold != PS1))
     begin
      shift_register_ps1 = 20'd0;
      PS1_hold = PS1;
      
      shift_register_ps1[7:0] = PS1;
      
      temp_hundreds_ps1 = shift_register_ps1[19:16];
      temp_tens_ps1 = shift_register_ps1[15:12];
      temp_ones_ps1 = shift_register_ps1[11:8];
      
      i = i+1;
     end
    if(i < 9 & i > 0)
     begin
      if(temp_hundreds_ps1 >= 5) temp_hundreds_ps1 = temp_hundreds_ps1 + 3;
      if(temp_tens_ps1 >= 5) temp_tens_ps1 = temp_tens_ps1 + 3;
      if(temp_ones_ps1 >= 5) temp_ones_ps1 = temp_ones_ps1 + 3;
      
      shift_register_ps1[19:8] = {temp_hundreds_ps1, temp_tens_ps1, temp_ones_ps1};
      shift_register_ps1 = shift_register_ps1 << 1;
      
      temp_hundreds_ps1 = shift_register_ps1[19:16];
      temp_tens_ps1 = shift_register_ps1[15:12];
      temp_ones_ps1 = shift_register_ps1[11:8];
      
      i = i + 1;
     end
    if(i == 9)
     begin
      i = 0;
      sumd1 = temp_tens_ps1;
      sumd2 = temp_ones_ps1;
     end 
     
    if(i == 0 & (PS2_hold != PS2))
     begin
      shift_register_ps2 = 20'd0;
      PS2_hold = PS2;
      
      shift_register_ps2[7:0] = PS2;
      
      temp_hundreds_ps2 = shift_register_ps2[19:16];
      temp_tens_ps2 = shift_register_ps2[15:12];
      temp_ones_ps2 = shift_register_ps2[11:8];
      
      i = i+1;
     end
    if(i < 9 & i > 0)
     begin
      if(temp_hundreds_ps2 >= 5) temp_hundreds_ps2 = temp_hundreds_ps2 + 3;
      if(temp_tens_ps2 >= 5) temp_tens_ps2 = temp_tens_ps2 + 3;
      if(temp_ones_ps2 >= 5) temp_ones_ps2 = temp_ones_ps2 + 3;
      
      shift_register_ps2[19:8] = {temp_hundreds_ps2, temp_tens_ps2, temp_ones_ps2};
      shift_register_ps2 = shift_register_ps2 << 1;
      
      temp_hundreds_ps2 = shift_register_ps2[19:16];
      temp_tens_ps2 = shift_register_ps2[15:12];
      temp_ones_ps2 = shift_register_ps2[11:8];
      
      i = i + 1;
     end
    if(i == 9)
     begin
      i = 0;
      sumd1 = temp_tens_ps2;
      sumd2 = temp_ones_ps2;
     end 
end

//Segment Output

localparam N = 18;
reg [N-1:0] count;
reg [6:0] sseg; //final sseg output
reg [6:0]an_temp; //keeps track of anodes for different output values to sseg

always@(posedge clk or posedge reset)
 begin
  if (reset)
   count <= 0;
  else
   count <= count + 1;
 end

always @(*)
 begin
   case(count[N-1:N-3])
   
   3'b000:
    begin
     sseg = diceroll;
     an_temp = 7'b1111110;
    end
    
   3'b001:
    begin
     sseg = p1d2;
     an_temp = 7'b1111101;
    end
     
   3'b010:
    begin
     sseg = p1d1;
     an_temp = 7'b1111011;
    end
    
   3'b011:
    begin
     sseg = sumd2;
     an_temp = 7'b1110111;
    end
    
   3'b100:
    begin
     sseg = sumd1;
     an_temp = 7'b1101111;
    end
    
   3'b101:
    begin
     sseg = p2d2;
     an_temp = 7'b1011111;
    end
    
   3'b110:
    begin
     sseg = p2d1;
     an_temp = 7'b0111111;
    end
    
   endcase
  end
  assign an = an_temp;
  reg [6:0] sseg_temp; 
  
always @ (*)
 begin
  case(sseg)
   4'b0000 : sseg_temp = 7'b1000000;
   4'b0001 : sseg_temp = 7'b1111001;
   4'b0010 : sseg_temp = 7'b0100100;
   4'b0011 : sseg_temp = 7'b0110000;
   4'b0100 : sseg_temp = 7'b0011001;
   4'b0101 : sseg_temp = 7'b0010010;
   4'b0110 : sseg_temp = 7'b0000010;
   4'b0111 : sseg_temp = 7'b1111000;
   4'b1000 : sseg_temp = 7'b0000000;
   4'b1001 : sseg_temp = 7'b0010000;
   default : sseg_temp = 7'b0111111; //dash
  endcase
 end
assign {g, f, e, d, c, b, a} = sseg_temp;

endmodule
